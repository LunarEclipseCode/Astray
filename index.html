<html>

<head>

    <script src='Box2dWeb.min.js'></script>
    <script src="Three.js"></script>
    <script src="keyboard.js"></script>
    <script src="jquery.js"></script>
    <script src="maze.js"></script>

    <script>

        var camera = undefined,
            scene = undefined,
            renderer = undefined,
            light = undefined,
            mouseX = undefined,
            mouseY = undefined,
            maze = undefined,
            mazeMesh = undefined,
            mazeDimension = 21,
            planeMesh = undefined,
            ballMesh = undefined,
            ballRadius = 0.225,
            ironTexture = THREE.ImageUtils.loadTexture('/ball.png'),
            planeTexture = THREE.ImageUtils.loadTexture('/concrete.png'),
            brickTexture = THREE.ImageUtils.loadTexture('/brick.png'),
            gameState = undefined,
            gamepadIndex = -1,
            spawnX = 0,
            spawnY = 0,
            exitX = 0,
            exitY = 0,
            exitCorner = 0, // 0=top-right, 1=bottom-right, 2=bottom-left, 3=top-left

            // Red balls
            redBalls = [],
            redBallMeshes = [],
            redBallPrevPos = [],
            numRedBalls = 0,

            // FPS Counter
            frameCount = 0,
            fps = 0,
            lastFpsUpdate = 0,

            // Box2D shortcuts
            b2World = Box2D.Dynamics.b2World,
            b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
            b2BodyDef = Box2D.Dynamics.b2BodyDef,
            b2Body = Box2D.Dynamics.b2Body,
            b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
            b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
            b2Settings = Box2D.Common.b2Settings,
            b2Vec2 = Box2D.Common.Math.b2Vec2,

            // Box2D world variables 
            wWorld = undefined,
            wBall = undefined;

        inputState = {
            left: false,
            right: false,
            up: false,
            down: false
        };


        function updateInputAxis() {
            var x = 0, y = 0;
            if (inputState.left) x -= 1;
            if (inputState.right) x += 1;
            if (inputState.up) y += 1;
            if (inputState.down) y -= 1;
            return [x, y];
        }

        function updateFPSCounter() {
            var currentTime = performance.now();
            frameCount++;

            if (currentTime - lastFpsUpdate > 500) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = currentTime;

                $('#performance').html(
                    'FPS: ' + fps
                );
            }
        }


        function createPhysicsWorld() {
            // Create the world object.
            wWorld = new b2World(new b2Vec2(0, 0), true);

            // Create the ball.
            var bodyDef = new b2BodyDef();
            bodyDef.type = b2Body.b2_dynamicBody;
            bodyDef.position.Set(spawnX, spawnY);
            wBall = wWorld.CreateBody(bodyDef);
            var fixDef = new b2FixtureDef();
            fixDef.density = 1.0;
            fixDef.friction = 0.0;
            fixDef.restitution = 0.25;
            fixDef.shape = new b2CircleShape(ballRadius);
            wBall.CreateFixture(fixDef);

            // Create red balls
            redBalls = [];
            redBallPrevPos = [];
            numRedBalls = Math.floor((mazeDimension) / 2);

            for (var i = 0; i < numRedBalls; i++) {
                var redBallDef = new b2BodyDef();
                redBallDef.type = b2Body.b2_dynamicBody;

                // Find a good spawn position for red ball
                var redX, redY;
                do {
                    redX = Math.floor(Math.random() * (mazeDimension - 2)) + 1;
                    redY = Math.floor(Math.random() * (mazeDimension - 2)) + 1;
                    // Ensure it's on a path (odd coordinates) and away from spawn
                } while (maze[redX][redY] || redX % 2 === 0 || redY % 2 === 0 ||
                    (Math.abs(redX - spawnX) < 3 && Math.abs(redY - spawnY) < 3));

                redBallDef.position.Set(redX, redY);
                var redBall = wWorld.CreateBody(redBallDef);

                var redFixDef = new b2FixtureDef();
                redFixDef.density = 1.0;
                redFixDef.friction = 0.0;
                redFixDef.restitution = 0.25;
                redFixDef.shape = new b2CircleShape(ballRadius);
                redBall.CreateFixture(redFixDef);

                // Add movement properties for back-and-forth movement
                // Pick a random direction: 0=horizontal, 1=vertical
                redBall.movementAxis = Math.floor(Math.random() * 2);
                redBall.direction = Math.random() < 0.5 ? -1 : 1;
                redBall.speed = 0.6 + Math.random() * 0.6; // Random speed between 0.6 and 1.2
                redBall.lastMove = 0;

                redBalls.push(redBall);
                redBallPrevPos.push({ x: redX, y: redY });
            }

            // Create the maze.
            bodyDef.type = b2Body.b2_staticBody;
            fixDef.shape = new b2PolygonShape();
            for (var j = 0; j < maze.dimension; j++) {
                var runStart = -1;
                for (var i = 0; i <= maze.dimension; i++) {
                    if (i < maze.dimension && maze[i][j]) {
                        if (runStart < 0) runStart = i;
                    } else if (runStart >= 0) {
                        var length = i - runStart;
                        var cx = runStart + length / 2 - 0.5;
                        bodyDef.position.Set(cx, j);
                        fixDef.shape.SetAsBox(length / 2, 0.5);
                        wWorld.CreateBody(bodyDef).CreateFixture(fixDef);
                        runStart = -1;
                    }
                }
            }
        }

        function generate_maze_mesh(field) {
            var dummy = new THREE.Geometry();
            var geometry = new THREE.CubeGeometry(1, 1, 1, 1, 1, 1);
            var mesh_ij = new THREE.Mesh(geometry);

            for (var i = 0; i < field.dimension; i++) {
                for (var j = 0; j < field.dimension; j++) {
                    if (field[i][j]) {
                        mesh_ij.position.set(i, j, 0.5);
                        THREE.GeometryUtils.merge(dummy, mesh_ij);
                    }
                }
            }
            var material = new THREE.MeshPhongMaterial({ map: brickTexture });
            return new THREE.Mesh(dummy, material);
        }


        function createRenderWorld() {

            // Create the scene object.
            scene = new THREE.Scene();

            // Add the light.
            light = new THREE.PointLight(0xffffff, 1);
            light.position.set(spawnX, spawnY, 1.3);
            scene.add(light);

            // Add the ball.
            g = new THREE.SphereGeometry(ballRadius, 32, 16);
            m = new THREE.MeshPhongMaterial({ map: ironTexture });
            ballMesh = new THREE.Mesh(g, m);
            ballMesh.position.set(spawnX, spawnY, ballRadius);
            scene.add(ballMesh);

            // Add red balls
            redBallMeshes = [];
            var redM = new THREE.MeshPhongMaterial({ map: ironTexture, color: 0xff0000 });
            for (var i = 0; i < redBalls.length; i++) {
                var redBallMesh = new THREE.Mesh(g, redM);
                var pos = redBalls[i].GetPosition();
                redBallMesh.position.set(pos.x, pos.y, ballRadius);
                scene.add(redBallMesh);
                redBallMeshes.push(redBallMesh);
            }

            // Add the camera.
            var aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 1, 1000);
            camera.position.set(spawnX, spawnY, 5);
            scene.add(camera);

            // Add the maze.
            mazeMesh = generate_maze_mesh(maze);
            scene.add(mazeMesh);

            // Add the ground.
            g = new THREE.PlaneGeometry(mazeDimension * 2, mazeDimension * 2, 10, 10);
            planeTexture.wrapS = planeTexture.wrapT = THREE.RepeatWrapping;
            planeTexture.repeat.set(mazeDimension, mazeDimension);
            m = new THREE.MeshPhongMaterial({ map: planeTexture });
            planeMesh = new THREE.Mesh(g, m);
            planeMesh.position.set((mazeDimension - 1) / 2, (mazeDimension - 1) / 2, 0);
            planeMesh.rotation.set(Math.PI / 2, 0, 0);
            scene.add(planeMesh);

        }


        function getGamepadInput() {
            if (gamepadIndex === -1) {
                return [0, 0];
            }

            var gamepads = navigator.getGamepads();
            var gamepad = gamepads[gamepadIndex];

            if (!gamepad) {
                return [0, 0];
            }

            var x = 0;
            var y = 0;

            var leftStickX = gamepad.axes[0];
            var leftStickY = gamepad.axes[1];

            var rightStickX = gamepad.axes[2];
            var rightStickY = gamepad.axes[3];

            var deadzone = 0.2;

            if (Math.abs(leftStickX) > deadzone) {
                x = leftStickX;
            }
            if (Math.abs(leftStickY) > deadzone) {
                y = -leftStickY; // Invert Y axis for correct up/down movement
            }

            // Process right joystick only if no input from left 
            if (Math.abs(rightStickX) > deadzone && x == 0 && y == 0) {
                x = rightStickX;
            }
            if (Math.abs(rightStickY) > deadzone && x == 0 && y == 0) {
                y = -rightStickY;
            }

            return [x, y];
        }


        function updateRedBalls() {
            for (var i = 0; i < redBalls.length; i++) {
                var redBall = redBalls[i];
                var pos = redBall.GetPosition();
                var vel = redBall.GetLinearVelocity();
                var currentTime = Date.now();

                // Only move every 80ms
                if (currentTime - redBall.lastMove > 80) {
                    redBall.lastMove = currentTime;

                    // Check if ball has stopped moving (hit a wall)
                    var currentSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
                    if (currentSpeed < 0.1) {
                        redBall.direction *= -1;
                    }

                    var moveX = 0, moveY = 0;

                    if (redBall.movementAxis === 0) { // Horizontal
                        moveX = redBall.direction * 0.1;
                    } else {
                        moveY = redBall.direction * 0.1;
                    }

                    // Apply movement force
                    var force = new b2Vec2(moveX * redBall.speed * 0.8, moveY * redBall.speed * 0.8);
                    redBall.ApplyImpulse(force, redBall.GetPosition());
                }

                // Apply friction to red balls
                var vel = redBall.GetLinearVelocity();
                vel.Multiply(0.85);
                redBall.SetLinearVelocity(vel);
            }
        }

        function checkCollisions() {
            var playerPos = wBall.GetPosition();

            for (var i = 0; i < redBalls.length; i++) {
                var redPos = redBalls[i].GetPosition();
                var distance = Math.sqrt(
                    Math.pow(playerPos.x - redPos.x, 2) +
                    Math.pow(playerPos.y - redPos.y, 2)
                );

                if (distance < ballRadius * 2) {
                    // Restart the level
                    gameState = 'initialize';
                    return;
                }
            }
        }

        function updatePhysicsWorld() {

            // Apply "friction". 
            var lv = wBall.GetLinearVelocity();
            lv.Multiply(0.95);
            wBall.SetLinearVelocity(lv);

            // Get input from both keyboard and gamepad
            var gamepadAxis = getGamepadInput();
            var keyAxis = updateInputAxis();
            var finalAxis;
            if (gamepadAxis[0] !== 0 || gamepadAxis[1] !== 0) {
                finalAxis = gamepadAxis;
            } else {
                finalAxis = keyAxis;
            }

            // Apply user-directed force.
            var f = new b2Vec2(finalAxis[0] * wBall.GetMass() * 0.25, finalAxis[1] * wBall.GetMass() * 0.25);
            wBall.ApplyImpulse(f, wBall.GetPosition());

            updateRedBalls();
            checkCollisions();

            // Take a time step.
            wWorld.Step(1 / 60, 8, 3);
        }

        function calcLevel(dimension) {
            if ((dimension - 21) % 6 === 0) {
                return (dimension - 21) / 3 + 1;
            } else {
                return (dimension - 19) / 3;
            }
        }

        function updateRenderWorld() {

            // Update ball position.
            var stepX = wBall.GetPosition().x - ballMesh.position.x;
            var stepY = wBall.GetPosition().y - ballMesh.position.y;
            ballMesh.position.x += stepX;
            ballMesh.position.y += stepY;

            // Update ball rotation.
            var tempMat = new THREE.Matrix4();
            tempMat.makeRotationAxis(new THREE.Vector3(0, 1, 0), stepX / ballRadius);
            tempMat.multiplySelf(ballMesh.matrix);
            ballMesh.matrix = tempMat;
            tempMat = new THREE.Matrix4();
            tempMat.makeRotationAxis(new THREE.Vector3(1, 0, 0), -stepY / ballRadius);
            tempMat.multiplySelf(ballMesh.matrix);
            ballMesh.matrix = tempMat;
            ballMesh.rotation.getRotationFromMatrix(ballMesh.matrix);

            // Update rotation of red balls
            for (var i = 0; i < redBalls.length; i++) {
                var redPos = redBalls[i].GetPosition();
                var prevPos = redBallPrevPos[i];

                var stepX = redPos.x - prevPos.x;
                var stepY = redPos.y - prevPos.y;

                // Update mesh position
                redBallMeshes[i].position.x = redPos.x;
                redBallMeshes[i].position.y = redPos.y;

                if (Math.abs(stepX) > 0.001 || Math.abs(stepY) > 0.001) {
                    redBallMeshes[i].rotation.y += stepX / ballRadius;
                    redBallMeshes[i].rotation.x += -stepY / ballRadius;
                }

                redBallPrevPos[i].x = redPos.x;
                redBallPrevPos[i].y = redPos.y;
            }

            // Update camera and light positions.
            camera.position.x += (ballMesh.position.x - camera.position.x) * 0.1;
            camera.position.y += (ballMesh.position.y - camera.position.y) * 0.1;
            camera.position.z += (5 - camera.position.z) * 0.1;
            light.position.x = camera.position.x;
            light.position.y = camera.position.y;
            light.position.z = camera.position.z - 3.7;
        }


        function gameLoop() {
            // updateFPSCounter();

            switch (gameState) {

                case 'initialize':
                    maze = generateSquareMaze(mazeDimension);

                    // Randomly select one of the four corners for the exit
                    exitCorner = Math.floor(Math.random() * 4);

                    // Create exit based on selected corner
                    switch (exitCorner) {
                        case 0: // Top-right
                            maze[mazeDimension - 1][mazeDimension - 2] = false;
                            exitX = mazeDimension;
                            exitY = mazeDimension - 2;
                            break;
                        case 1: // Bottom-right
                            maze[mazeDimension - 1][1] = false;
                            exitX = mazeDimension;
                            exitY = 1;
                            break;
                        case 2: // Bottom-left
                            maze[0][1] = false;
                            exitX = -1;
                            exitY = 1;
                            break;
                        case 3: // Top-left
                            maze[0][mazeDimension - 2] = false;
                            exitX = -1;
                            exitY = mazeDimension - 2;
                            break;
                    }

                    // Set spawn position to center of maze
                    spawnX = Math.floor(mazeDimension / 2);
                    spawnY = Math.floor(mazeDimension / 2);
                    // Ensure spawn is on an odd coordinate
                    if (spawnX % 2 === 0) spawnX++;
                    if (spawnY % 2 === 0) spawnY++;

                    createPhysicsWorld();
                    createRenderWorld();
                    camera.position.set(spawnX, spawnY, 5);
                    light.position.set(spawnX, spawnY, 1.3);
                    light.intensity = 0;
                    var level = calcLevel(mazeDimension);
                    $('#level').html('Level ' + level);
                    gameState = 'fade in';
                    break;

                case 'fade in':
                    light.intensity += 0.1 * (1.0 - light.intensity);
                    renderer.render(scene, camera);
                    if (Math.abs(light.intensity - 1.0) < 0.05) {
                        light.intensity = 1.0;
                        gameState = 'play'
                    }
                    break;

                case 'play':
                    updatePhysicsWorld();
                    updateRenderWorld();
                    renderer.render(scene, camera);

                    // Check for victory.
                    var mazeX = Math.floor(ballMesh.position.x + 0.5);
                    var mazeY = Math.floor(ballMesh.position.y + 0.5);
                    if (mazeX == exitX && mazeY == exitY) {
                        var currLevel = calcLevel(mazeDimension);
                        var nextLevel = currLevel + 1;
                        if (nextLevel % 2 === 0) {
                            mazeDimension += 4;
                        } else {
                            mazeDimension += 2;
                        }
                        gameState = 'fade out';
                    }
                    break;

                case 'fade out':
                    updatePhysicsWorld();
                    updateRenderWorld();
                    light.intensity += 0.1 * (0.0 - light.intensity);
                    renderer.render(scene, camera);
                    if (Math.abs(light.intensity - 0.0) < 0.1) {
                        light.intensity = 0.0;
                        renderer.render(scene, camera);
                        gameState = 'initialize'
                    }
                    break;

            }

            requestAnimationFrame(gameLoop);

        }


        function onResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }


        jQuery.fn.centerv = function () {
            wh = window.innerHeight;
            h = this.outerHeight();
            this.css("position", "absolute");
            this.css("top", Math.max(0, (wh - h) / 2) + "px");
            return this;
        }


        jQuery.fn.centerh = function () {
            ww = window.innerWidth;
            w = this.outerWidth();
            this.css("position", "absolute");
            this.css("left", Math.max(0, (ww - w) / 2) + "px");
            return this;
        }


        jQuery.fn.center = function () {
            this.centerv();
            this.centerh();
            return this;
        }


        $(document).ready(function () {

            // Prepare the instructions.
            $('#instructions').center();
            $('#instructions').hide();
            KeyboardJS.bind.key('i', function () { $('#instructions').show() },
                function () { $('#instructions').hide() });

            // Add gamepad event listeners
            window.addEventListener("gamepadconnected", function (e) {
                gamepadIndex = e.gamepad.index;
            });

            window.addEventListener("gamepaddisconnected", function (e) {
                gamepadIndex = -1;
            });

            // Create the renderer.
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Bind keyboard and resize events.
            KeyboardJS.bind.key('left', function () { inputState.left = true; }, function () { inputState.left = false; });
            KeyboardJS.bind.key('right', function () { inputState.right = true; }, function () { inputState.right = false; });
            KeyboardJS.bind.key('up', function () { inputState.up = true; }, function () { inputState.up = false; });
            KeyboardJS.bind.key('down', function () { inputState.down = true; }, function () { inputState.down = false; });

            // WASD keys
            KeyboardJS.bind.key('a', function () { inputState.left = true; }, function () { inputState.left = false; });
            KeyboardJS.bind.key('d', function () { inputState.right = true; }, function () { inputState.right = false; });
            KeyboardJS.bind.key('w', function () { inputState.up = true; }, function () { inputState.up = false; });
            KeyboardJS.bind.key('s', function () { inputState.down = true; }, function () { inputState.down = false; });

            // Vim keys
            KeyboardJS.bind.key('h', function () { inputState.left = true; }, function () { inputState.left = false; });
            KeyboardJS.bind.key('l', function () { inputState.right = true; }, function () { inputState.right = false; });
            KeyboardJS.bind.key('k', function () { inputState.up = true; }, function () { inputState.up = false; });
            KeyboardJS.bind.key('j', function () { inputState.down = true; }, function () { inputState.down = false; });
            $(window).resize(onResize);


            // Set the initial game state.
            gameState = 'initialize';

            // Start the game loop.
            requestAnimationFrame(gameLoop);

        })



    </script>

    <style>
        body {
            background: black;
            margin: 0;
            padding: 0;
            font-family: 'Helvetica';
        }

        #instructions {
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            text-align: center;
            padding: 32px;
            margin: 0px;
            display: inline;
            border: 2px solid white;
        }

        #help {
            position: absolute;
            left: 0px;
            bottom: 0px;
            padding: 4px;
            color: white;
        }

        #level {
            position: absolute;
            left: 0px;
            top: 0px;
            padding: 4px;
            color: yellow;
            font-weight: bold;
        }

        #performance {
            position: absolute;
            left: 0px;
            top: 30px;
            padding: 4px;
            color: #00ff00;
            font-weight: bold;
            font-size: 12px;
        }
    </style>

</head>

<body>

    <div id='instructions'>
        How to play Astray:
        <br><br>
        Use the arrow keys to move the ball and find the exit to the maze.
        <br><br>
        Vim trainees: h, j, k, l
    </div>

    <div id='help'>
        Hold down the 'I' key for instructions.
    </div>

    <div id='level'>
        Level 1
    </div>
    <!-- <div id='performance'>
        FPS: 0
    </div> -->
</body>

</html>